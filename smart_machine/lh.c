#include <reg51.h>
#include <absacc.h>
#define ADDR_KEY_READ			0x9001
#define ADDR_KEY_WRITE		0x9002

unsigned char code KEY_NUMBER[]={

7,	8,	9,	10,	'T',	'R',

4,	5,	6,	11,	'S',	'M',

1,	2,	3,	12,	'H',	'L',

0,	15,	14,	13,	'X',	'N'
};//按键键名

//显示按键键名
#define MODE_0	(unsigned char)0
#define MODE_1	(unsigned char)1
#define MODE_2	(unsigned char)2
#define MODE_3	(unsigned char)3

#define PD1  61        //  122/2 分成左右两半屏(122x32)

unsigned char Column;
unsigned char Page_ ;  // 页地址寄存器 D1,DO:页地址
unsigned char Code_ ;  // 字符代码寄存器

unsigned char Command; // 指令寄存器
unsigned char LCDData; // 数据寄存器

xdata unsigned char CWADD1 _at_ 0x8000;   // 写指令代码地址(E1)
xdata unsigned char DWADD1 _at_ 0x8001;   // 写显示数据地址(E1)
xdata unsigned char CRADD1 _at_ 0x8002;   // 读状态字地址(E1)
xdata unsigned char DRADD1 _at_ 0x8003;   // 读显示数据地址(E1)

xdata unsigned char CWADD2 _at_ 0x8004;   // 写指令代码地址(E2)
xdata unsigned char DWADD2 _at_ 0x8005;   // 写显示数进地址(E2)
xdata unsigned char CRADD2 _at_ 0x8006;   // 读状态字地址(E2)
xdata unsigned char DRADD2 _at_ 0x8007;   // 读显示数据地址(E2)

////英文字模库    8x8 点阵
//code unsigned char EETAB[][8]={
//        {0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00},  // 0
//        {0x10,0x30,0x50,0x10,0x10,0x10,0x7c,0x00},  // 1
//        {0x38,0x44,0x04,0x08,0x10,0x20,0x7c,0x00},  // 2
//        {0x78,0x84,0x04,0x38,0x04,0x84,0x78,0x00}}; // 3

// 中文字模库   16x16点阵
code unsigned char CCTAB[][32] ={
        {	0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,
0x40,0x40,0x40,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00},//上

        {	0x10,0x0C,0x04,0xE4,0x24,0x24,0x25,0x26,0x24,0x24,0x24,0xE4,0x04,0x14,0x0C,0x00,
0x00,0x00,0x00,0xFF,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0xF8,0x00,0x00,0x00},//官

        {	0x44,0x58,0xC0,0x7F,0xD0,0x48,0x00,0x2A,0x12,0xBE,0x00,0x2A,0x92,0x3E,0x00,0x00,
0x80,0x60,0x1F,0x00,0x7F,0x20,0x14,0x02,0xFF,0x55,0x55,0x7F,0x55,0x55,0x41,0x00},//耀

        {	0x10,0x60,0x02,0x8C,0x00,0xFE,0x02,0xF2,0x52,0x5A,0x56,0x52,0x52,0xF2,0x02,0x00,
0x04,0x04,0x7E,0x41,0x30,0x0F,0x20,0x13,0x49,0x81,0x7F,0x01,0x09,0x13,0x20,0x00},//源
//*****************************************************************************************************				
				{0x00,0x20,0x10,0xE8,0x24,0x27,0xA4,0xA4,0xA4,0xA4,0xB4,0xAC,0x20,0x20,0x00,0x00,
0x80,0x40,0x30,0x0F,0x00,0x00,0x3F,0x40,0x40,0x44,0x48,0x47,0x40,0x70,0x00,0x00},//危

				{0x02,0x02,0x02,0x02,0xC2,0xB2,0x8E,0x82,0x82,0x82,0x82,0x82,0x82,0x02,0x02,0x00,
0x08,0x04,0x02,0x01,0xFF,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0x00,0x00,0x00},//石
				
				{0x10,0x10,0x10,0x10,0x10,0x10,0xD0,0x30,0xFF,0x10,0x10,0x10,0x10,0x10,0x10,0x00,
0x00,0x20,0x10,0x08,0x04,0x03,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//才
				
				{0x40,0x42,0xCC,0x00,0x00,0xE2,0x22,0x2A,0x2A,0xF2,0x2A,0x26,0x22,0xE0,0x00,0x00,
0x80,0x40,0x3F,0x40,0x80,0xFF,0x89,0x89,0x89,0xBF,0x89,0xA9,0xC9,0xBF,0x80,0x00},//通
				
				{0x00,0x00,0x00,0xFC,0x04,0x04,0x16,0x65,0x04,0x44,0x84,0x7C,0x00,0x00,0x00,0x00,
0x00,0x10,0x10,0x13,0x12,0x12,0x12,0x12,0x12,0x12,0x52,0x82,0x42,0x3E,0x00,0x00},//鸟
				
				{0x40,0x40,0x42,0xCC,0x00,0x08,0xE9,0xAA,0xB8,0xA8,0xA8,0xAA,0xE9,0x08,0x00,0x00,
0x00,0x40,0x20,0x1F,0x20,0x40,0x5F,0x4A,0x4A,0x4A,0x4A,0x4A,0x5F,0x40,0x40,0x00},//道
				
				{0x10,0x0C,0x44,0x24,0x14,0x04,0x05,0x06,0x04,0x04,0x14,0x24,0x44,0x14,0x0C,0x00,
0x00,0x40,0x40,0x41,0x41,0x41,0x41,0x7F,0x41,0x41,0x41,0x41,0x40,0x40,0x00,0x00},//空
				
				{0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,
0x00,0x00,0x3F,0x20,0x20,0x20,0x20,0x3F,0x20,0x20,0x20,0x20,0x7F,0x00,0x00,0x00},//山
				
				{0x02,0x02,0xF2,0x92,0x92,0x92,0x92,0xFE,0x92,0x92,0x92,0x92,0xF2,0x02,0x02,0x00,
0x80,0x80,0x87,0x4C,0x54,0x24,0x34,0x4F,0x44,0x44,0x84,0x84,0x87,0x80,0x80,0x00},//更

				{0x04,0x04,0x04,0x84,0xE4,0x3C,0x27,0x24,0x24,0x24,0x24,0xE4,0x04,0x04,0x04,0x00,
0x04,0x02,0x01,0x00,0xFF,0x09,0x09,0x09,0x09,0x49,0x89,0x7F,0x00,0x00,0x00,0x00},//有

				{0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x40,0x20,0x10,0x0C,0x03,0x00,0x00,0x00,0x03,0x0C,0x10,0x20,0x40,0x80,0x00},//人
				
				{0x10,0x2C,0x24,0x24,0xA4,0xA4,0x65,0xA6,0x24,0x24,0x24,0x24,0xA4,0x34,0x0C,0x00,
0x40,0x49,0x49,0x29,0x24,0x14,0x52,0x89,0x7F,0x04,0x0A,0x11,0x10,0x20,0x20,0x00},//家
//*****************************************************************************************************		
				{0x10,0x10,0xD0,0xFF,0x90,0x10,0x08,0x90,0xFF,0x00,0x00,0xFF,0xA0,0x10,0x08,0x00,
0x04,0x03,0x00,0xFF,0x00,0x83,0x41,0x30,0x0F,0x00,0x00,0x7F,0x80,0x81,0xF2,0x00},//桃
				
				{0x00,0xFE,0x02,0x42,0x4A,0xCA,0x4A,0x4A,0xCA,0x4A,0x4A,0x42,0x02,0xFE,0x00,0x00,
0x00,0xFF,0x40,0x50,0x4C,0x43,0x40,0x40,0x4F,0x50,0x50,0x5C,0x40,0xFF,0x00,0x00},//园
				
				{0x10,0x0C,0x44,0x44,0x44,0x44,0x45,0xC6,0x44,0x44,0x44,0x44,0x44,0x14,0x0C,0x00,
0x80,0x40,0x20,0x1E,0x20,0x40,0x40,0x7F,0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x00},//定
				
				{0x08,0x08,0x88,0xC8,0x38,0x0C,0x0B,0x08,0x08,0xE8,0x08,0x08,0x08,0x08,0x08,0x00,
0x02,0x01,0x00,0xFF,0x40,0x41,0x41,0x41,0x41,0x7F,0x41,0x41,0x41,0x41,0x40,0x00},//在

				{0x10,0x60,0x02,0x8C,0x00,0x0E,0x22,0x12,0x0A,0xC2,0x0A,0x12,0x22,0x0E,0x00,0x00,
0x04,0x04,0x7E,0x01,0x20,0x21,0x11,0x09,0x05,0xFF,0x05,0x09,0x11,0x21,0x20,0x00},//深

				{0x00,0x80,0x60,0x9F,0x08,0x08,0xF8,0x00,0x00,0xFF,0x10,0x20,0x40,0x80,0x00,0x00,
0x81,0x40,0x20,0x13,0x0C,0x13,0x20,0x20,0x40,0x5F,0x40,0x40,0x40,0x41,0x40,0x00},//处
				
				{0x10,0x60,0x02,0x8C,0x00,0xFC,0x01,0xE6,0x20,0x22,0x22,0xE2,0x02,0xFE,0x00,0x00,
0x04,0x04,0x7E,0x01,0x00,0xFF,0x00,0x0F,0x09,0x09,0x09,0x4F,0x80,0x7F,0x00,0x00},//涧
				
				{0x00,0x20,0x20,0x20,0xA0,0x60,0x00,0xFF,0x60,0x80,0x40,0x20,0x18,0x00,0x00,0x00,
0x20,0x10,0x08,0x06,0x01,0x40,0x80,0x7F,0x00,0x01,0x02,0x04,0x08,0x10,0x10,0x00},//水

				{0x10,0x60,0x02,0x0C,0xC0,0x00,0x94,0xA4,0x84,0x94,0xA2,0x82,0xA3,0x1A,0x00,0x00,
0x04,0x04,0x7C,0x03,0x00,0x04,0x04,0x04,0x44,0x84,0x7E,0x05,0x04,0x04,0x04,0x00},//浮
				
				{0x00,0x08,0x08,0x28,0xC8,0x08,0x08,0xFF,0x08,0x08,0x88,0x68,0x08,0x08,0x00,0x00,
0x21,0x21,0x11,0x11,0x09,0x05,0x03,0xFF,0x03,0x05,0x09,0x11,0x11,0x21,0x21,0x00},//来
				
				{0x84,0x04,0x14,0x64,0x0F,0x04,0x84,0x44,0xB4,0x24,0x2F,0xA4,0x64,0x04,0x04,0x00,
0x08,0x0B,0xF8,0x04,0x03,0x04,0x04,0xFA,0x4A,0x49,0x49,0x4A,0xFA,0x04,0x04,0x00},//落
				
				{0x04,0x04,0x04,0x84,0x6F,0x04,0x04,0x04,0xE4,0x04,0x8F,0x44,0x24,0x04,0x04,0x00,
0x04,0x02,0x01,0xFF,0x00,0x10,0x08,0x04,0x3F,0x41,0x40,0x40,0x40,0x40,0x78,0x00},//花
				
//*****************************************************************************************************		
				{0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1
				
				{0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//6
				
				{0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//&


};



unsigned char key_scan(void);										//按键扫描
void Delay5ms();																//软件延时
void DisplayMode_switch(unsigned char key_num);	//LCD显示模式切换
				 

void WriteCommandE1();		// 1.写指令代码子程序(E1)		 
void WriteDataE1();				// 2.写显示数据子程序(E1)		 
void ReadDataE1();				// 3.读显示数据子程序(E1)			 
void WriteCommandE2();		// 4.写指令代码子程序(E2)			 
void WriteDataE2();				// 5.写显示数据子程序(E2)			 
void ReadDataE2();				// 6.读显示数据子程序(E2)	 
void Init();							// 初始化程序	
void Clear();							// 清屏
void Delay();							// 延时程序
void WriteCHN16x16();			// 中文显示子程序
void WriteEN8x8(void);		//英文显示子程序


void main(void)
{
	unsigned char key_pos = 0;
	
	//LCD初始化
	Init();
  Clear();

			Page_ = 0x03;
			Column = 0x00+5;
			Code_ = 0x1C;
			WriteCHN16x16();
	
			Page_ = 0x03;
			Column = 0x10+5;
			Code_ = 0x1D;
			WriteCHN16x16();
	
			Page_ = 0x03;
			Column = 0x20+5;
			Code_ = 0x1E;
			WriteCHN16x16();
	
	
	
			Page_ = 0x03;
			Column = 0x30+5;
			Code_ = 0x00;
			WriteCHN16x16();
	
			Page_ = 0x03;
			Column = 0x40+5;
			Code_ = 0x01;
			WriteCHN16x16();
	
			Page_ = 0x03;
			Column = 0x50+5;
			Code_ = 0x02;
			WriteCHN16x16();
			
			Page_ = 0x03;
			Column = 0x60+5;
			Code_ = 0x03;
			WriteCHN16x16();
			
			while(key_scan() == 0xff);
			Clear();
	
	while(1)
	{
		key_pos = key_scan();
		if(key_pos != 0xff)
			DisplayMode_switch(KEY_NUMBER[key_pos]);
		
	}
	
	
}

void DisplayMode_switch(unsigned char key_num)
{
	switch(key_num)
	{
		case 7://显示模式0
		{
			Page_ = 0x02;			//设置显示行
			Column = 13;		//设置显示列
			Code_ = 0x04;
			WriteCHN16x16();
			
		}break;
		case 8://显示模式1
		{
			Page_ = 0x02;
			Column = 0x10;
			Code_ = 0x05;
			WriteCHN16x16();
			
		}break;
		case 9://显示模式2
		{
			Page_ = 0x02;
			Column = 0x20;
			Code_ = 0x06;
			WriteCHN16x16();
			
		}break;
		case 10://显示模式3
		{
			Page_ = 0x02;
			Column = 0x30;
			Code_ = 0x07;
			WriteCHN16x16();
			
		}break;
		case ('T')://显示模式4
		{
			Page_ = 0x02;
			Column = 0x40;
			Code_ = 0x08;
			WriteCHN16x16();
			
		}break;
		case ('R')://显示模式5
		{
			Page_ = 0x02;
			Column = 0x50;
			Code_ = 0x09;
			WriteCHN16x16();
			
		}break;
		
		//*******************************************
		
		case 4://显示模式0
		{
			Page_ = 0x00;			//设置显示行
			Column = 0x00;		//设置显示列
			Code_ = 0x0A;
			WriteCHN16x16();
			
		}break;
		case 5://显示模式1
		{
			Page_ = 0x00;
			Column = 0x10;
			Code_ = 0x0B;
			WriteCHN16x16();
			
		}break;
		case 6://显示模式2
		{
			Page_ = 0x00;
			Column = 0x20;
			Code_ = 0x0C;
			WriteCHN16x16();
			
		}break;
		case 11://显示模式3
		{
			Page_ = 0x00;
			Column = 0x30;
			Code_ = 0x0D;
			WriteCHN16x16();
			
		}break;
		case ('S')://显示模式4
		{
			Page_ = 0x00;
			Column = 0x40;
			Code_ = 0x0E;
			WriteCHN16x16();
			
		}break;
		case ('M')://显示模式5
		{
			Page_ = 0x00;
			Column = 0x50;
			Code_ = 0x0F;
			WriteCHN16x16();
			
		}break;
		
		//*******************************************
		
		case 1://显示模式0
		{
			Page_ = 0x02;			//设置显示行
			Column = 0x00;		//设置显示列
			Code_ = 0x10;
			WriteCHN16x16();
			
		}break;
		case 2://显示模式1
		{
			Page_ = 0x02;
			Column = 0x10;
			Code_ = 0x11;
			WriteCHN16x16();
			
		}break;
		case 3://显示模式2
		{
			Page_ = 0x02;
			Column = 0x20;
			Code_ = 0x12;
			WriteCHN16x16();
			
		}break;
		case 12://显示模式3
		{
			Page_ = 0x02;
			Column = 0x30;
			Code_ = 0x13;
			WriteCHN16x16();
			
		}break;
		case ('H')://显示模式4
		{
			Page_ = 0x02;
			Column = 0x40;
			Code_ = 0x14;
			WriteCHN16x16();
			
		}break;
		case ('L')://显示模式5
		{
			Page_ = 0x02;
			Column = 0x50;
			Code_ = 0x15;
			WriteCHN16x16();
			
		}break;
		
		//*******************************************
		
		//*******************************************
		
		case 0://显示模式0
		{
			Page_ = 0x00;			//设置显示行
			Column = 0x00;		//设置显示列
			Code_ = 0x16;
			WriteCHN16x16();
			
		}break;
		case 15://显示模式1
		{
			Page_ = 0x00;
			Column = 0x10;
			Code_ = 0x17;
			WriteCHN16x16();
			
		}break;
		case 14://显示模式2
		{
			Page_ = 0x00;
			Column = 0x20;
			Code_ = 0x18;
			WriteCHN16x16();
			
		}break;
		case 13://显示模式3
		{
			Page_ = 0x00;
			Column = 0x30;
			Code_ = 0x19;
			WriteCHN16x16();
			
		}break;
		case ('X')://显示模式4
		{
			Page_ = 0x00;
			Column = 0x40;
			Code_ = 0x1A;
			WriteCHN16x16();
			
		}break;
		case ('N')://显示模式5
		{
			Page_ = 0x00;
			Column = 0x50;
			Code_ = 0x1B;
			WriteCHN16x16();
			
		}break;
		
		
		default:break;//其余情况不更新显示
		
	}
	
}

unsigned char key_scan(void)
{
	unsigned char scan_data = 0x20;//列扫描用IO输出数据
	unsigned char row = 0, col = 0;
	unsigned char key_pos = 0xff;
	//检测是否有按键按下
	XBYTE[ADDR_KEY_WRITE] = 0x00;
	if((XBYTE[ADDR_KEY_READ] & 0x0f) != 0x0f)//有按键按下
	{
		//按键消抖
		Delay5ms();
		Delay5ms();
		Delay5ms();
		Delay5ms();
		Delay5ms();
		Delay5ms();
			
		
		//进行列检测
		XBYTE[0x9004] = 0x00;
		XBYTE[ADDR_KEY_WRITE] = scan_data;
		while((XBYTE[ADDR_KEY_READ] & 0x0f) != 0x0f)//检测到0x0f时即找到该列
		{
			col ++;
			scan_data  = scan_data >> 1;
			XBYTE[ADDR_KEY_WRITE] = scan_data;
			
		}
//		if(col > 5)
//		{
//			return 0xff;//产生错误
//			
//		}
		
		//进行行检测
		XBYTE[ADDR_KEY_WRITE] = 0x00;
		switch(XBYTE[ADDR_KEY_READ] & 0x0f)
		{
			case 0x07:row = 0;break;
			case 0x0b:row = 1;break;
			case 0x0d:row = 2;break;
			case 0x0e:row = 3;break;
			default:key_pos = 0xff;break;
			
		}
		
		//合成按键位置
		key_pos = row*6 + col;
		
//		if((key_pos % 6) < 4 && (key_pos % 6) > 0)
			while((XBYTE[ADDR_KEY_READ] & 0x0f) != 0x0f);
//		else
//			return 0xff;
		
		
		return key_pos;
		
	}
	else if((XBYTE[ADDR_KEY_READ] & 0x0f) == 0x0f)//没有按键按下
	{
		
		return 0xff;//返回特殊值
		
	}
	
}




void Delay5ms()		//@12.000MHz
{
	unsigned char i, j;

	i = 10;
	j = 183;
	do
	{
		while (--j);
	} while (--i);
}


// 1.写指令代码子程序(E1)
void WriteCommandE1()
{
  while(CRADD1 & 0x80);
  CWADD1 = Command;
}

// 2.写显示数据子程序(E1)
void WriteDataE1()
{
  while(CRADD1 & 0x80);
  DWADD1 = LCDData;
}

// 3.读显示数据子程序(E1)
void ReadDataE1()
{
  while(CRADD1 & 0x80);
  LCDData = DRADD1;
}

// 4.写指令代码子程序(E2)
void WriteCommandE2()
{
  while(CRADD2 & 0x80);
  CWADD2 = Command;
}

// 5.写显示数据子程序(E2)
void WriteDataE2()
{
  while(CRADD2 & 0x80);
  DWADD2 = LCDData;
}

// 6.读显示数据子程序(E2)
void ReadDataE2()
{
  while(CRADD2 & 0x80);
  LCDData = DRADD2;
}

// 初始化程序
void Init()
{
  Command = 0xe2;
  WriteCommandE1();
  WriteCommandE2();

  Command = 0xa4;
  WriteCommandE1();
  WriteCommandE2();

  Command = 0xa9;
  WriteCommandE1();
  WriteCommandE2();

  Command = 0xa0;
  WriteCommandE1();
  WriteCommandE2();

  Command = 0xc0;
  WriteCommandE1();
  WriteCommandE2();

  Command = 0xaf;
  WriteCommandE1();
  WriteCommandE2();
}

// 清屏
void Clear()
{
  unsigned char i,j;

  i = 0;
  do {

    Command = (i + 0xb8); // 页地址设置
    WriteCommandE1();
    WriteCommandE2();

    Command = 0x00;      // 列地址设置为"0"
    WriteCommandE1();
    WriteCommandE2();

    j = 0x50;            // 一页清 80个字节
    do {
      LCDData = 0x00;    // 显示数据为"0"
      WriteDataE1();
      WriteDataE2();
    }while(--j !=0);     // 页内字节清零循环

  }while(++i !=4);       // 页地址暂存器加一
                         // 显示区清零循环
}

// 延时程序
void Delay()
{
  unsigned char i,j;
  i = 20;
  j = 0;
  do{
    do{
    }while(--j !=0);
  }while( --i != 0 );
}

// 中文显示子程序
void WriteCHN16x16()
{
  unsigned char i,j,k;

  i = 0;
  j = 0;
  while(j<2) {
    Command = ((Page_ + j) & 0x03) | 0xb8;   // 设置页地址
    WriteCommandE1();
    WriteCommandE2();
    k = Column;                   // 列地址值
    while(k < Column + 16){
      if (k < PD1) {              // 为左半屏显示区域(E1)
        Command = k;
        WriteCommandE1();         // 设置列地址值
        LCDData = CCTAB[Code_][i]; // 取汉字字模数据
        WriteDataE1();            // 写字模数据
      } else{                     // 为右半屏显示区域(E2)
        Command = k-PD1;
        WriteCommandE2();         // 设置列地址值
        LCDData = CCTAB[Code_][i]; // 取汉字字模数据
        WriteDataE2();            // 写字模数据
      };

      i++;
      if( ++k >= PD1 * 2) break;  // 列地址是否超出显示范围
    } ;
    j++;
  };
}

//英文显示子程序
void WriteEN8x8(void)
{
	  unsigned char i,j,k;

		i = 0;
		j = 0;
	
		Command = ((Page_ + j) & 0x03) | 0xb8;   // 设置页地址
    WriteCommandE1();
    WriteCommandE2();
    k = Column;                   // 列地址值

      if (k < PD1) {              // 为左半屏显示区域(E1)
        Command = k;
        WriteCommandE1();         // 设置列地址值
        LCDData = CCTAB[Code_][i]; // 取汉字字模数据
        WriteDataE1();            // 写字模数据
      } else{                     // 为右半屏显示区域(E2)
        Command = k-PD1;
        WriteCommandE2();         // 设置列地址值
        LCDData = CCTAB[Code_][i]; // 取汉字字模数据
        WriteDataE2();            // 写字模数据
      };

      i++;
//      if( ++k >= PD1 * 2)  // 列地址是否超出显示范围
	
}

